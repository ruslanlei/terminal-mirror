/*
 * Copyright (C) 2002 - 2023 Devexperts LLC
 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
import{Subject as o}from"rxjs";import{logValueToUnit as u,percentToUnit as d,calcLogValue as b}from"../../model/scaling/viewport.model";import{AnimationFrameCache as g}from"../../utils/perfomance/animation-frame-cache.utils";import{identity as m}from"../../utils/function.utils";import{MathUtils as l}from"../../utils/math.utils";import{PriceIncrementsUtils as L}from"../../utils/price-increments.utils";const x=0,p=.01;export class NumericAxisLabelsGenerator{constructor(e,s,a,t,r=!1,i,n,c=m){this.increment=e,this.startEndProvider=s,this.lengthProvider=a,this.valueFormatter=t,this.withZero=r,this.axisTypeProvider=i,this.baseLineProvider=n,this.labelFilter=c,this.gridDistanceMultipliers=[2,4,5,10],this.lastSingleLabelHeightValue=0,this.distanceBetweenLabelsChangeSubject=new o,this.newGeneratedLabelsSubject=new o,this.lastStart=0,this.lastEnd=0,this.labelsCache=new g(()=>this.labelFilter(this.doGenerateLabels()))}generateRegularLabels(e,s,a){const t=[];this.withZero&&t.push({value:0,text:"0"});let r=l.roundToNearest(e,a);for(;r<s;){const i=l.roundToNearest(r,a),n=this.valueFormatter(i);t.push({value:i,text:n}),r=l.roundDecimal(r+a)}return t}generatePercentLabels(e,s,a){const t=[],r=this.baseLineProvider();let i=l.roundToNearest(e,a);for(;i<s;){const n=l.roundToNearest(i,a),c=d(n,r),h=this.valueFormatter(c);t.push({value:n,text:h}),i=l.roundDecimal(i+a)}return t}generateLogarithmLabels(e,s,a){const t=[];let r=l.roundToNearest(e,a);for(;r<s;){const i=u(r),n=this.valueFormatter(i);t.push({value:r,text:n}),r=l.roundDecimal(r+a)}return t}doGenerateLabels(){var e;const s=this.lengthProvider();if(s<=0)return[];const[a,t]=this.calculateMinMax(),r=this.getAxisStep(a,t,s);this.lastSingleLabelHeightValue||(this.lastSingleLabelHeightValue=r);let i;const n=this.axisTypeProvider();if(n==="logarithmic"?i=this.generateLogarithmLabels(a,t,r):n==="percent"?i=this.generatePercentLabels(a,t,r):i=this.generateRegularLabels(a,t,r),this.lastSingleLabelHeightValue!==r&&this.labelsCache.cache){const c=(e=this.labelsCache.getLastCachedValue())!==null&&e!==void 0?e:[];this.distanceBetweenLabelsChangeSubject.next([c,i]),this.lastSingleLabelHeightValue=r}return this.newGeneratedLabelsSubject.next(i),i}calculateMinMax(){const[e,s]=this.startEndProvider(),a=this.lengthProvider(),t=NumericAxisLabelsGenerator.getLabelBounds(e,s,a);return[t[0],t[1]]}getAxisStep(e,s,a){const t=s-e,i=a/23,n=this.calculateIncrement(t),c=t/i;return this.calculateAxisStep(c,n)}observeDistanceBetweenLabelsChanged(){return this.distanceBetweenLabelsChangeSubject.asObservable()}observeLabelsChanged(){return this.newGeneratedLabelsSubject.asObservable()}calculateIncrement(e){if(this.increment)return this.increment;if(!isNaN(e)){const s=L.autoDetectIncrementOfValueRange(e);return this.adjustIncrementOnAxisType(s)}return this.adjustIncrementOnAxisType(p)}adjustIncrementOnAxisType(e){switch(this.axisTypeProvider()){case"percent":return e;case"logarithmic":const[s]=this.calculateMinMax(),t=u(s)+e;return b(t)-s;case"regular":return e}}generateNumericLabels(){const[e,s]=this.startEndProvider();return(e!==this.lastStart||s!==this.lastEnd)&&this.labelsCache.invalidate(),this.lastStart=e,this.lastEnd=s,this.labelsCache.calculateOrGet()}static getLabelBounds(e,s,a){const t=Math.abs((s-e)*(x/a));return[e-t,s+t]}calculateAxisStep(e,s){if(s===0)return console.error("NumericAxisLabelsGenerator failed at calculateAxisStep: increment = 0"),0;let a=s,t=s,r=0;for(;a<e&&a>0;)r>=this.gridDistanceMultipliers.length&&(r=0,t*=10),a=t*this.gridDistanceMultipliers[r++];return a}}
