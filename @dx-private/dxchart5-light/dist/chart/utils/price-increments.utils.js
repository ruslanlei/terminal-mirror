/*
 * Copyright (C) 2002 - 2023 Devexperts LLC
 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
import{floor as i,MathUtils as u}from"./math.utils";class o{static autoDetectIncrementOfValueRange(r){const a=this.getDigitsInNumber(r);return r===0?.01:Math.pow(10,a-3)}static getDigitsInNumber(r){const a=h=>i(Math.log10((h^h>>31)-(h>>31)))+1;let t=a(r);return t===1&&r<1&&(t=a(r*1e9)-9),t}static getPriceIncrement(r,a=[]){if(!this.validatePriceIncrementsOrPrecisions(a))return this.DEFAULT_INCREMENT;if(isNaN(r))return Math.round(a[0]);r=Math.abs(r);let t=1;const h=1e-6;for(;t<a.length&&r>a[t]+Math.min(a[t-1],a[t+1])*h;)t+=2;return t>=a.length||r<a[t]-Math.min(a[t-1],a[t+1])*h?a[t-1]:Math.min(a[t-1],a[t+1])}static getPricePrecision(r,a){if(!this.validatePriceIncrementsOrPrecisions(a))return 0;if(isNaN(r))return Math.round(a[0]);r=Math.abs(r);let t=1;for(;t<a.length&&r>a[t];)t+=2;return Math.round(a[t-1])}static roundPriceToIncrement(r,a,t){const h=o.getPriceIncrement(t||r,a);return u.roundToNearest(r,h)}static computePrecisions(r){const a=[...r];for(let t=0;t<r.length;t+=2)a[t]=o.calculatePrecision(r[t]);for(let t=1;t<r.length;t+=2)a[t]=r[t]+Math.min(r[t-1],r[t+1])*o.RELATIVE_EPS;return a}static calculatePrecision(r){let a=r>1?Math.abs(Math.floor(r)-r):r;for(let t=0;t<o.MAXIMUM_PRECISION;t++){const h=Math.floor(a+.5),M=Math.abs(a*o.RELATIVE_EPS);if(h>=a-M&&h<=a+M)return t;a*=10}return o.MAXIMUM_PRECISION}static validatePriceIncrementsOrPrecisions(r){return!(r.length===0||!Array.isArray(r)||r.findIndex(a=>a!==0)===-1)}}o.DEFAULT_INCREMENT=.01,o.DEFAULT_PRECISION=2,o.RELATIVE_EPS=1e-8,o.MAXIMUM_PRECISION=10;export{o as PriceIncrementsUtils};
