/*
 * Copyright (C) 2002 - 2023 Devexperts LLC
 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
import{arrayIntersect as e,eqeqeq as n,reorderArray as E}from"../../common/array.functions";import{EVENT_DRAW as h}from"../events";import{uuid as _}from"../utils";import{debounce as A}from"../utils/optimization.utils";import{animationFrameThrottled as R}from"../utils/request-animation-frame-throttle.utils";export const HIT_TEST_PREFIX="HIT_TEST_";export var DrawerType;(function(i){i.MAIN_BACKGROUND="MAIN_BACKGROUND",i.MAIN_CLEAR="MAIN_CLEAR",i.HIT_TEST_CLEAR="HIT_TEST_CLEAR",i.YAXIS_CLEAR="YAXIS_CLEAR",i.SERIES_CLEAR="SERIES_CLEAR",i.OVER_SERIES_CLEAR="OVER_SERIES_CLEAR",i.HIT_TEST_DRAWINGS="HIT_TEST_DRAWINGS",i.GRID="GRID",i.VOLUMES="VOLUMES",i.UNDERLAY_VOLUMES_AREA="UNDERLAY_VOLUMES_AREA",i.X_AXIS="X_AXIS",i.Y_AXIS="Y_AXIS",i.HIGH_LOW="HIGH_LOW",i.DRAWINGS="DRAWINGS",i.DATA_SERIES="DATA_SERIES",i.N_MAP_CHART="N_MAP_CHART",i.PL_CHART="PL_CHART",i.WATERMARK="WATERMARK",i.EMPTY_CHART="EMPTY_CHART",i.OFFLINE_CHART="OFFLINE_CHART",i.LABELS="LABELS",i.EVENTS="EVENTS",i.HIT_TEST_EVENTS="HIT_TEST_EVENTS",i.PL_ZERO_LINE="ZERO_LINE",i.PL_ZERO_LINE_BACKGROUND="PL_ZERO_LINE_BACKGROUND",i.CROSS_TOOL="CROSS_TOOL"})(DrawerType||(DrawerType={}));export class DrawingManager{constructor(s,r){this.chartResizeHandler=r,this.drawingOrder=[],this.drawersMap={},this.canvasIdsList=[],this.animFrameId=`draw_${_()}`,s.on(h,t=>{r.wasResized()&&(this.canvasIdsList&&(t&&t.length!==0?this.canvasIdsList=this.canvasIdsList.concat(t):this.canvasIdsList=void 0),R(this.animFrameId,()=>{this.forceDraw(this.canvasIdsList),this.canvasIdsList=[]}))}),this.drawHitTestCanvas=A(()=>{this.drawingOrder.forEach(t=>{t.indexOf(HIT_TEST_PREFIX)!==-1&&this.drawersMap[t].draw()})},20)}redrawCanvasesImmediate(){this.chartResizeHandler.fireUpdates(),this.forceDraw()}drawLastBar(){this.drawingOrder.forEach(s=>{if(s.indexOf(HIT_TEST_PREFIX)===-1){const r=this.drawersMap[s];r.drawLastBar&&r.drawLastBar()}})}forceDraw(s){this.drawingOrder.forEach(r=>{if(r.indexOf(HIT_TEST_PREFIX)===-1){const t=this.drawersMap[r];if(!s||s.length===0){t.draw();return}e(s,t.getCanvasIds(),n).length!==0&&t.draw()}})}drawHitTestOnly(){this.drawHitTestCanvas()}addDrawer(s,r){this.drawingOrder.indexOf(r)===-1&&this.drawingOrder.push(r),this.drawersMap[r]=s}addDrawerAfter(s,r,t){this.addDrawer(s,r);const d=this.drawingOrder.indexOf(r);this.drawingOrder.splice(d,1);const a=this.drawingOrder.indexOf(t);this.drawingOrder.splice(a+1,0,r),this.reorderDrawers(this.drawingOrder)}addDrawerBefore(s,r,t){this.addDrawer(s,r);const d=this.drawingOrder.indexOf(t);if(d!==-1){const a=this.drawingOrder.indexOf(r);return this.drawingOrder.splice(a,1),this.drawingOrder.splice(d,0,r),this.reorderDrawers(this.drawingOrder),!0}return!1}getDrawerByName(s){return this.drawersMap[s]}getNameByDrawer(s){for(const r in this.drawersMap)if(this.drawersMap[r]===s)return r}removeDrawerByName(s){const r=this.drawersMap[s];this.removeDrawer(r)}removeDrawer(s){Object.keys(this.drawersMap).forEach(r=>{if(this.drawersMap[r]===s){delete this.drawersMap[r];const t=this.drawingOrder.indexOf(r);t!==-1&&this.drawingOrder.splice(t,1)}})}reorderDrawers(s){this.drawingOrder=E(this.drawingOrder,s)}}export class DynamicDrawerType{static paneResizer(s){return`PANE_RESIZER_${s}`}}
