/*
 * Copyright (C) 2002 - 2023 Devexperts LLC
 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
import{moveInArrayMutable as o,reorderArray as a,slice2DArray as r}from"../array.functions";describe("array functions",()=>{describe("slice 2D array",()=>{it("should correctly slice arrays with correct indexes",()=>{const t=[[1,2],[3,4]],e=r(t,1,2);expect(e.toString()).toBe([[2],[3]].toString());const s=r(t,0,1);expect(s.toString()).toBe([[1,2]].toString());const n=r(t,2,3);expect(n.toString()).toBe([[3,4]].toString());const c=r(t,0,3);expect(c.toString()).toBe([[1,2],[3,4]].toString())}),it("should corrercly slice arrays with exceeding indexes",()=>{const t=[[1,2],[3,4]],e=r(t,-2,0);expect(e.toString()).toBe([[1]].toString());const s=r(t,3,4);expect(s.toString()).toBe([[4]].toString());const n=r(t,-2,4);expect(n.toString()).toBe([[1,2],[3,4]].toString())})}),describe("reorder array",()=>{it("Reorders source array according to newOrder",()=>{const t=["1","2","3"],e=a(t,["3","1"]);expect(e.toString()).toBe(["3","2","1"].toString());const s=a(t,["3","1","2"]);expect(s.toString()).toBe(["3","1","2"].toString());const n=a(t,["3"]);expect(n.toString()).toBe(["1","2","3"].toString())}),it("should return the reordered array even if newOrder contains duplicates",()=>{const t=["1","2","3"],e=["2","1","2"];expect(a(t,e)).toEqual(["2","1","3"])}),it("should return the reordered array even if newOrder contains extra elements",()=>{const t=["1","2","3"],e=["6","2","1","5"];expect(a(t,e)).toEqual(["2","1","3"])})}),describe("moveInArrayMutable",()=>{it("should move an item from start to end",()=>{const e=o([1,2,3,4,5],1,3);expect(e).toEqual([1,3,4,2,5])}),it("should move an item from end to start",()=>{const e=o([1,2,3,4,5],4,1);expect(e).toEqual([1,5,2,3,4])}),it("should move an item to the same position",()=>{const e=o([1,2,3,4,5],2,2);expect(e).toEqual([1,2,3,4,5])}),it("should clamp from and to if start and end are out of bounds",()=>{const e=o([1,2,3,4,5],-1,6);expect(e).toEqual([2,3,4,5,1])}),it("should return the same array if start and end are the same",()=>{const e=o([1,2,3,4,5],2,2);expect(e).toEqual([1,2,3,4,5])}),it("should return the same array if we try to move first element outside left bound",()=>{const e=o([1,2,3,4,5],0,-1);expect(e).toEqual([1,2,3,4,5])})})});
