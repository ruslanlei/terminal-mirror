/*
 * Copyright (C) 2002 - 2023 Devexperts LLC
 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
import{merge as n,Subject as h}from"rxjs";import{CanvasElement as b}from"../../../canvas/canvas-bounds-container";import{ChartBaseElement as c}from"../../../chart-base-element";import{uuid as v}from"../../../utils";import{calcLabelsYCoordinates as u}from"../../../utils/labels-positions-calculator.utils";import{animationFrameThrottledPrior as p}from"../../../utils/request-animation-frame-throttle.utils";export const LabelsGroups={MAIN:"MAIN"};export class YAxisLabelsModel extends c{constructor(e,s,t,i,r,o){super(),this.eventBus=e,this.chartModel=s,this.canvasBoundsContainer=t,this.config=i,this.canvasModel=r,this.updateYAxisWidth=o,this.orderedLabels=[],this.customLabels={},this.labelsProviders={},this.labelsPositionRecalculatedSubject=new h,this.animFrameId=`anim_cache_${v()}`,this.initModel()}doActivate(){super.doActivate(),this.addRxSubscription(n(this.chartModel.observeCandlesChanged(),this.canvasBoundsContainer.observeBoundsChanged(b.CHART),this.chartModel.nextCandleTimeStampSubject,this.canvasBoundsContainer.barResizerChangedSubject,this.chartModel.scaleModel.changed).subscribe(()=>{this.updateLabels()}))}initModel(){this.initLabelsGroups(),this.recalculateLabels(),this.canvasModel.fireDraw()}initLabelsGroups(){if(Object.keys(this.labelsProviders).length!==0)for(const e of Object.keys(this.labelsProviders))this.createGroup(e),Object.entries(this.labelsProviders[e]).forEach(([s,t])=>{this.addToGroup(t,e,s)})}updateLabels(e=!1){this.recalculateLabels(),p(this.animFrameId,()=>{e&&this.updateYAxisWidth(),this.canvasModel.fireDraw()})}recalculateLabels(){var e,s;this.orderedLabels=[];const t=this.config.components.yAxis.fontSize+((e=this.config.components.yAxis.labelBoxMargin.top)!==null&&e!==void 0?e:0)+((s=this.config.components.yAxis.labelBoxMargin.bottom)!==null&&s!==void 0?s:0);for(const i of Object.values(this.labelsProviders)){const r=Object.values(i).map(a=>a.getUnorderedLabels()).flat(),o=r.map(a=>a.labels).flat().map(a=>{var l;return{y:a.y,weight:(l=a.labelWeight)!==null&&l!==void 0?l:Number.POSITIVE_INFINITY}}),d=u(o,t);r.forEach(a=>{const l=d.splice(0,a.labels.length);this.orderedLabels.push(this.updateLabelsCoordinates(a,l))})}this.orderedLabels=this.orderedLabels.reverse()}createGroup(e){!this.labelsProviders[e]&&(this.labelsProviders[e]={})}addToGroup(e,s,t){this.labelsProviders[s]&&(Object.values(this.labelsProviders[s]).includes(e)||(this.labelsProviders[s][t]=e))}updateLabelsCoordinates(e,s){return Object.assign(Object.assign({},e),{labels:e.labels.map((t,i)=>Object.assign(Object.assign({},t),{lineY:t.y,y:s[i]}))})}observeLabelsPositionsRecalculated(){return this.labelsPositionRecalculatedSubject.asObservable()}registerYAxisLabelsProvider(e,s,t){var i;const r=(i=this.labelsProviders[e])!==null&&i!==void 0?i:{};r[t]=s,this.labelsProviders[e]=r,this.initModel()}unregisterYAxisLabelsProvider(e,s){var t;const i=(t=this.labelsProviders[e])!==null&&t!==void 0?t:{};delete i[s],this.labelsProviders[e]&&Object.keys(this.labelsProviders[e]).length===0&&delete this.labelsProviders[e],this.initModel()}}
