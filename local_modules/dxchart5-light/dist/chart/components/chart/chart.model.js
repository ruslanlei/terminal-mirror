/*
 * Copyright (C) 2002 - 2023 Devexperts LLC
 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
import{Subject as m,merge as D}from"rxjs";import{distinctUntilChanged as U}from"rxjs/operators";import{ChartBaseElement as W}from"../../chart-base-element";import{CHART_UUID as C,CanvasElement as S,areBoundsChanged as _}from"../../canvas/canvas-bounds-container";import{getDefaultConfig as j}from"../../chart.config";import{MIN_SUPPORTED_CANVAS_SIZE as b}from"../../drawers/canvas.model";import{CandleSeriesModel as V}from"../../model/candle-series.model";import{copyCandle as O}from"../../model/candle.model";import{candleEdgesConstrait as L}from"../../model/scaling/constrait.functions";import{pixelsToUnits as M}from"../../model/scaling/viewport.model";import{floor as Y,round as X}from"../../utils";import{autoDetectPeriod as P}from"../../utils/auto-period-detector.utils";import{merge as R}from"../../utils/merge.utils";import{binarySearch as w,lastOf as I,searchCandleIndex as f}from"../../utils/utils-index";import{createBasicScaleViewportTransformer as N,createTimeFrameViewportTransformer as Z}from"./basic-scale";import{calculateCandleWidth as k}from"./candle-width-calculator.functions";import{deleteCandlesIndex as z,prepareCandle as g,reindexCandles as T}from"./candle.functions";import{ChartInstrument as H}from"./chart.component";import{fakeCandle as v,fakeVisualCandle as K}from"./fake-candles";import{SecondaryChartColorsPool as $}from"./secondary-chart-colors-pool";export class ChartModel extends W{get mainCandleSeries(){return this.candleSeries[0]}get secondaryCandleSeries(){return this.candleSeries.filter(e=>e!==this.mainCandleSeries)}constructor(e,t,s,a,i,d,n,l,r){super(),this.paneManager=e,this.bus=t,this.canvasModel=s,this.config=a,this.scaleModel=i,this.formatterFactory=d,this.mainCanvasParent=n,this.canvasBoundsContainer=l,this.chartResizeHandler=r,this.prevChartWidth=0,this.prevYWidth=0,this.period=0,this.candleSeries=[],this.candlesUpdatedSubject=new m,this.candlesSetSubject=new m,this.candlesRemovedSubject=new m,this.candlesPrependSubject=new m,this.nextCandleTimeStampSubject=new m,this.axisTypeSetSubject=new m,this.chartTypeChanged=new m,this.mainInstrumentChangedSubject=new m,this.scaleInversedSubject=new m,this.offsetsChanged=new m,this.candlesTransformersByChartType={},this.lastCandleLabelsByChartType={},this.candleWidthByChartType={},this.lastTimeFrame=[0,0],this.FAKE_CANDLES_DEFAULT=100,this.toY=o=>this.mainCandleSeries.view.toY(o),this.getPeriod=()=>this.period,this.chartTypeChanged.next(this.config.components.chart.type),this.secondaryChartColors=new $(this.config),this.candleSeries[0]=this.createCandleSeriesModel(new H,Object.assign({},this.config.colors)),this.mainCandleSeries.config.type=this.config.components.chart.type,i.addXConstraint((o,c)=>L(c,this.mainCandleSeries.visualPoints,this.config.components.chart.minCandlesOffset,i.getBounds())),this.basicScaleViewportTransformer=N(i),this.timeFrameViewportTransformer=Z(i,this),this.pane=this.paneManager.paneComponents[C]}doActivate(){super.doActivate(),this.addRxSubscription(this.canvasBoundsContainer.observeBoundsChanged(S.PANE_UUID(C)).pipe(U(_)).subscribe(e=>{this.handleChartResize(e)})),this.addRxSubscription(this.canvasBoundsContainer.barResizerChangedSubject.subscribe(()=>this.recalculateViewportModelZoomY()))}handleChartResize(e){if(e.width>b.width&&e.height>b.height){const t=this.getEffectiveChartWidth(),s=this.getEffectiveYAxisWidth();if(this.prevChartWidth===0){this.scaleModel.isViewportValid()?this.scaleModel.recalculateZoom():this.doBasicScale(),this.prevChartWidth=t,this.prevYWidth=s;return}if(s!==this.prevYWidth){if(this.config.scale.keepZoomXOnYAxisChange){const i=M(s-this.prevYWidth,this.scaleModel.zoomX);this.scaleModel.setXScale(this.scaleModel.xStart,this.scaleModel.xEnd-i)}else this.scaleModel.recalculateZoomX();this.prevYWidth=s,this.prevChartWidth=t;return}const a=M(t-this.prevChartWidth,this.scaleModel.zoomX);this.scaleModel.setXScale(this.scaleModel.xStart-a,this.scaleModel.xEnd),this.scaleModel.recalculateZoomY(),this.prevYWidth=s,this.prevChartWidth=t}}recalculateViewportModelZoomY(){this.scaleModel.recalculateZoomY(),this.scaleModel.fireChanged(),this.bus.fireDraw([this.canvasModel.canvasId])}setMainCandleSeries(e,t){this.mainCandleSeries.instrument=t,this.setAllSeries({candles:e,instrument:t},this.getSecondarySeries().map(s=>{const a=s.dataPoints;return z(a),{candles:a,instrument:s.instrument}}))}setSecondaryCandleSeries(e,t=this.mainCandleSeries.instrument,s=!0){const a=x(e.map(g)),i=this.reindexCandlesBasedOnSeries(this.mainCandleSeries.dataPoints,a),d=this.secondarySeriesAdjustments(this.mainCandleSeries.dataPoints,i),l=this.secondaryCandleSeries.some(r=>r.instrument.symbol===t.symbol)?this.secondaryCandleSeries.find(r=>r.instrument.symbol===t.symbol):this.createSecondaryCandleSeriesModel(t);if(l)return l.dataPoints=d,s&&(this.scaleModel.doAutoScale(),l.recalculateVisualPoints(),this.candlesSetSubject.next(),this.bus.fireDraw([this.canvasModel.canvasId])),l}setAllSeries(e,t=[]){var s;this.mainCandleSeries.instrument=(s=e.instrument)!==null&&s!==void 0?s:this.mainCandleSeries.instrument,e.instrument&&this.mainInstrumentChangedSubject.next(e.instrument),this.rememberCurrentTimeframe();const a=x(e.candles.map(g));this.mainCandleSeries.clearData(),T(a),this.mainCandleSeries.dataPoints=a,this.secondaryCandleSeries.filter(i=>t.filter(d=>{var n;return((n=d.instrument)===null||n===void 0?void 0:n.symbol)===i.instrument.symbol}).length===0).forEach(i=>this.removeSecondaryCandleSeries(i)),t.map(i=>this.setSecondaryCandleSeries(i.candles,i.instrument,!1)),this.candleSeries.forEach(i=>{i.recalculateDataViewportIndexes(),i.recalculateVisualPoints()}),this.recalculatePeriod(),this.autoScaleOnCandles(),this.scaleModel.doAutoScale(),this.candlesSetSubject.next(),this.bus.fireDraw([this.canvasModel.canvasId])}recalculatePeriod(){const e=P(this.mainCandleSeries.dataPoints);e&&(this.period=e)}autoScaleOnCandles(){this.scaleModel.state.autoScaleOnCandles&&(this.doBasicScale(),this.scaleModel.autoScale(!0))}doBasicScale(){this.basicScaleViewportTransformer(this.mainCandleSeries.visualPoints),this.bus.fireDraw()}doPreviousTimeFrameScale(e=null){this.timeFrameViewportTransformer(this.lastTimeFrame,e),this.scaleModel.state.autoScaleOnCandles&&this.scaleModel.doAutoScale(!0),this.bus.fireDraw()}rememberCurrentTimeframe(){this.mainCandleSeries.visualPoints.length!==0&&(this.lastTimeFrame=[this.candleFromX(this.scaleModel.toX(this.scaleModel.xStart),!0).timestamp,this.candleFromX(this.scaleModel.toX(this.scaleModel.xEnd),!0).timestamp])}updateAllSeries(e,t){const s=[e,...t];if(!this.candleSeries.every(l=>s.find(r=>{var o;return((o=r.instrument)===null||o===void 0?void 0:o.symbol)===l.instrument.symbol}))||t.length!==this.secondaryCandleSeries.length){console.error("All series update failed. Instruments for series are different.");return}const a=x(e.candles.map(g)),i=F(this.mainCandleSeries.dataPoints,a),d=i.candles;T(d),this.mainCandleSeries.dataPoints=d,t.map(l=>{var r,o,c,p;const u=x(l.candles.map(g)),y=F((p=(c=this.findSecondarySeriesBySymbol((o=(r=l.instrument)===null||r===void 0?void 0:r.symbol)!==null&&o!==void 0?o:""))===null||c===void 0?void 0:c.dataPoints)!==null&&p!==void 0?p:[],u).candles;return this.setSecondaryCandleSeries(y,l.instrument,!1)}),this.candleSeries.forEach(l=>{l.recalculateVisualPoints(),l.recalculateDataViewportIndexes()}),this.scaleModel.moveXStart(this.scaleModel.xStart+i.prepended),this.candlesPrependSubject.next(i.prepended);const n=P(this.mainCandleSeries.dataPoints);n&&(this.period=n),this.candlesUpdatedSubject.next(),this.bus.fireDraw()}removeDataFrom(e){Object.values(this.paneManager.paneComponents).forEach(t=>{t.dataSeries.forEach(s=>{const a=w(s.dataPoints,e,d=>d.timestamp),i=a.exact?a.index:a.index+1;s.dataPoints=s.dataPoints.slice(0,i)})}),this.candlesRemovedSubject.next(),this.candlesUpdatedSubject.next(),this.canvasModel.fireDraw()}createSecondaryCandleSeriesModel(e){const t=Object.assign(Object.assign({},this.config.colors),this.secondaryChartColors.takeColorFromPool(e.symbol));return this.createCandleSeriesModel(e,t)}createCandleSeriesModel(e,t){const s=new V(this.paneManager.paneComponents[C],this.paneManager.hitTestController.getNewDataSeriesHitTestId(),this.bus,this.scaleModel,e,this.candlesTransformersByChartType,this.candleWidthByChartType,t);return s.config.type="line",this.candleSeries.push(s),s}removeSecondaryCandleSeries(e){return this.secondaryChartColors.addColorToPool(e.instrument.symbol),this.candleSeries=this.candleSeries.filter(t=>t!==e),e.deactivate(),this.paneManager.paneComponents[C].removeDataSeries(e),this.scaleModel.doAutoScale(),e.colors}secondarySeriesAdjustments(e,t){const s=[];return e.forEach(a=>{var i;const d=(i=a.idx)!==null&&i!==void 0?i:0,n=t[d];if(n)s.push(n);else{let l=E(t,d,-1);if(l||(l=E(t,d,1)),l){const r=O(l,d,!0);s.push(r)}}}),s}updateSecondaryCandleSeriesConfig(e,t,s){const a=R(e,j().colors);this.secondaryChartColors.updateColorConfig(t,a);const i=this.findSecondarySeriesBySymbol(t);i&&(i.config.type=s,i.updateCandleSeriesColors(a),this.bus.fireDraw([this.canvasModel.canvasId])),this.bus.fireDraw([this.canvasModel.canvasId])}setAutoScale(e){this.scaleModel.autoScale(e)}getEffectiveYAxisWidth(){return this.canvasBoundsContainer.getBounds(S.PANE_UUID_Y_AXIS(C)).width}getEffectiveChartWidth(){return this.canvasBoundsContainer.getBounds(S.PANE_UUID(C)).width}getEffectiveChartHeight(){return this.canvasBoundsContainer.getBounds(S.PANE_UUID(C)).height}setOffsets(e){this.scaleModel.updateOffsets(e);const t=this.getCandlesCountWithRightOffset(),s=this.mainCandleSeries.visualPoints;this.hasCandles()&&t>=s.length&&this.scaleModel.setXScale(this.scaleModel.xStart,this.candleFromIdx(t).startUnit),this.offsetsChanged.next(),this.bus.fireDraw()}getOffsets(){return this.scaleModel.getOffsets()}fromY(e){return this.scaleModel.fromY(e)}priceFromY(e,t){return(t!=null?t:this.mainCandleSeries).view.priceFromY(e)}toX(e){const t=this.candleFromIdx(e);return this.scaleModel.toX(t.centerUnit)}getBaseLine(){return this.mainCandleSeries.getBaseLine()}candleFromX(e,t=!1,s=this.mainCandleSeries){const a=this.scaleModel.fromX(e);return this.candleFromUnit(a,t,s)}candleFromUnit(e,t=!1,s=this.mainCandleSeries){var a,i;const d=w(s.visualPoints,e,c=>c.startUnit),n=s.visualPoints,l=this.getLastVisualCandle();n[d.index]!==void 0&&(e<0||l&&e>l.startUnit+l.width)&&(d.index+=X((e-n[d.index].centerUnit)/this.mainCandleSeries.meanCandleWidth));const r=d.index,o=Math.max(Math.min(n.length-1,r),0);return(r<0||r>=n.length)&&t?v(this.mainCandleSeries.dataPoints,r,this.getPeriod()):(i=(a=n[o])===null||a===void 0?void 0:a.candle)!==null&&i!==void 0?i:v(this.mainCandleSeries.dataPoints,o,this.getPeriod())}candleFromTimestamp(e,t=!0){const s=f(e,t,this.mainCandleSeries.dataPoints,this.getPeriod());return this.candleFromIdx(s.index)}candleFromIdx(e){const t=this.mainCandleSeries.visualPoints[e];return t||K(this.mainCandleSeries,e,this.getPeriod())}isReady(){return this.canvasModel.isReady()&&this.hasCandles()}registerCandlesTransformer(e,t){this.candlesTransformersByChartType[e]=t}registerCandlesWidthCalculator(e,t){this.candleWidthByChartType[e]=t}registerLastCandleLabelHandler(e,t){this.lastCandleLabelsByChartType[e]=t}hasCandles(){return this.mainCandleSeries.visualPoints.length!==0}getVisualCandle(e){var t,s,a;const i=e-((a=(s=(t=this.mainCandleSeries.visualPoints[0])===null||t===void 0?void 0:t.candle)===null||s===void 0?void 0:s.idx)!==null&&a!==void 0?a:0);return this.mainCandleSeries.visualPoints[i]}getFirstIdx(){return this.mainCandleSeries.dataIdxStart}getLastIdx(){return this.mainCandleSeries.dataIdxEnd}getFirstTimestamp(e=!0){return e?this.candleFromIdx(this.getFirstIdx()).candle.timestamp:this.candleFromUnit(this.scaleModel.xStart,!0).timestamp}getLastTimestamp(e=!0){return e?this.candleFromIdx(this.getLastIdx()).candle.timestamp:this.candleFromUnit(this.scaleModel.xEnd,!0).timestamp}setTimestampRange(e,t){const s=this.candleFromTimestamp(e).startUnit,a=this.candleFromTimestamp(t),i=a.startUnit+a.width;return this.scaleModel.setXScale(s,i)}getLastCandle(){const e=this.mainCandleSeries.dataPoints;return I(e)}getLastVisualCandle(){const e=this.mainCandleSeries.visualPoints;return I(e)}getMaxCandlesFitLength(){return Y(this.getEffectiveChartWidth()/this.config.components.chart.minWidth)}getSecondarySeries(){return this.secondaryCandleSeries}isSeriesInstrument(e,t){return e.instrument.symbol===t}findSeriesBySymbol(e){return this.candleSeries.filter(t=>this.isSeriesInstrument(t,e))}findSecondarySeriesBySymbol(e){return this.secondaryCandleSeries.find(t=>this.isSeriesInstrument(t,e))}reindexCandlesBasedOnSeries(e,t){const s=this.getPeriod();return t.reduce((a,i)=>{const d=i.timestamp,n=f(d,!1,e,s);return n.index>=0&&n.index<e.length&&(i.idx=n.index,a[n.index]=i),a},[])}isCandleInViewport(e){return this.getFirstIdx()<=e&&e<=this.getLastIdx()}updateCandles(e,t=this.mainCandleSeries.instrument.symbol){const s=this.mainCandleSeries.instrument.symbol===t,a=this.findSeriesBySymbol(t);if(a.length===0){console.warn("updateCandles failed. Can't find series",t);return}a.forEach(i=>{const d=i.dataPoints;let n=!1,l=!1,r;e.forEach(o=>{var c;if(!o)return;const p=f(o.timestamp,!0,d,this.getPeriod()),u=Math.min(p.index,d.length);n=n||u===d.length,d[u]=o,o.idx=u,i.dataPoints=d,i.recalculateDataViewportIndexes(),l=l||this.isCandleInViewport(u);const y=u>=d.length-1,B=r&&o.timestamp<r.timestamp;if(y&&!B&&(r=o),n&&r&&s&&l){const A=(c=this.candleWidthByChartType[this.config.components.chart.type])!==null&&c!==void 0?c:k;this.scaleModel.moveXStart(this.scaleModel.xStart+A(r))}}),r&&i.updateCurrentPrice(r.close),l&&r&&e.length===1?this.bus.fireDraw([this.canvasModel.canvasId]):i.recalculateVisualPoints()}),this.scaleModel.doAutoScale(),this.candlesUpdatedSubject.next()}observeCandlesChanged(){return D(this.candlesSetSubject,this.candlesUpdatedSubject)}getCandles(){return this.mainCandleSeries.dataPoints}getCandlesWithFake(e=0,t){let s=this.getCandles().slice();const a=this.getCandlesCount(),i=t!=null?t:a+this.FAKE_CANDLES_DEFAULT;s=s.slice(Math.max(0,e),Math.min(a,i));const d=[],n=[];for(let r=a;r<i;r++)d.push(v(this.mainCandleSeries.dataPoints,r,this.getPeriod()));const l=Math.min(0,i);for(let r=e;r<l;r++)n.push(v(this.mainCandleSeries.dataPoints,r,this.getPeriod()));return[...n,...s,...d]}getCandlesCount(){return this.mainCandleSeries.dataPoints.length}getCandlesCountWithRightOffset(){return this.getCandlesCount()+this.getOffsets().right}clearData(){this.candleSeries.forEach(e=>e.clearData())}prependCandles(e,t){const s=e.slice(),a=[];return t.forEach(i=>{const n=f(i.timestamp,!1,e).index;n<0?a.push(i):e[n].timestamp===i.timestamp?s[n]=i:console.warn(`Couldn't update candle with timestamp ${i.timestamp}`)}),{prepended:a.length,candles:[...a,...s]}}addLastCandle(e,t=this.mainCandleSeries.instrument.symbol){this.updateCandles([e],t)}updateLastCandle(e,t=this.mainCandleSeries.instrument.symbol){this.updateCandles([e],t)}}const x=h=>h.slice().sort((e,t)=>e.timestamp===t.timestamp?0:e.timestamp>t.timestamp?1:-1),E=(h,e,t)=>{if(e>=h.length)return h[h.length-1];for(let s=e;s<h.length&&s>=0;s+=t){const a=h[s];if(a)return a}},F=(h,e)=>{const t=h.slice(),s=[],a=[];return e.forEach(i=>{const n=f(i.timestamp,!0,h).index;n<0?s.push(i):n>=h.length?a.push(i):h[n].timestamp===i.timestamp?t[n]=i:console.warn(`Couldn't update candle with timestamp ${i.timestamp}`)}),{prepended:s.length,appended:a.length,candles:[...s,...t,...a]}};
