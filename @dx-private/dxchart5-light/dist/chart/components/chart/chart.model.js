/*
 * Copyright (C) 2002 - 2023 Devexperts LLC
 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
import{Subject as m,merge as A}from"rxjs";import{distinctUntilChanged as D}from"rxjs/operators";import{ChartBaseElement as U}from"../../model/chart-base-element";import{CHART_UUID as C,CanvasElement as f,areBoundsChanged as W}from"../../canvas/canvas-bounds-container";import{getDefaultConfig as _}from"../../chart.config";import{MIN_SUPPORTED_CANVAS_SIZE as x}from"../../model/canvas.model";import{CandleSeriesModel as j}from"../../model/candle-series.model";import{copyCandle as V}from"../../model/candle.model";import{MainCandleSeriesModel as O}from"../../model/main-candle-series.model";import{candleEdgesConstrait as L}from"../../model/scaling/constrait.functions";import{pixelsToUnits as M}from"../../model/scaling/viewport.model";import{merge as Y}from"../../utils/merge.utils";import{createBasicScaleViewportTransformer as X,createTimeFrameViewportTransformer as R}from"./basic-scale";import{calculateCandleWidth as N}from"./candle-width-calculator.functions";import{deleteCandlesIndex as Z,prepareCandle as S,reindexCandles as b}from"./candle.functions";import{ChartInstrument as z}from"./chart.component";import{fakeCandle as g}from"./fake-candles";import{SecondaryChartColorsPool as H}from"./secondary-chart-colors-pool";import{binarySearch as w,lastOf as P}from"../../utils/array.utils";import{searchCandleIndex as v}from"../../utils/candles.utils";import{floor as k,round as K}from"../../utils/math.utils";export class ChartModel extends U{get mainCandleSeries(){return this.candleSeries[0]}get secondaryCandleSeries(){return this.candleSeries.filter(e=>e!==this.mainCandleSeries)}constructor(e,t,s,i,a,n,r,d,l,o){super(),this.chartBaseModel=e,this.paneManager=t,this.bus=s,this.canvasModel=i,this.config=a,this.scaleModel=n,this.formatterFactory=r,this.mainCanvasParent=d,this.canvasBoundsContainer=l,this.chartResizeHandler=o,this.prevChartWidth=0,this.prevYWidth=0,this.candleSeries=[],this.candlesUpdatedSubject=new m,this.candlesSetSubject=new m,this.candlesRemovedSubject=new m,this.candlesPrependSubject=new m,this.nextCandleTimeStampSubject=new m,this.axisTypeSetSubject=new m,this.chartTypeChanged=new m,this.mainInstrumentChangedSubject=new m,this.scaleInversedSubject=new m,this.offsetsChanged=new m,this.candlesTransformersByChartType={},this.lastCandleLabelsByChartType={},this.candleWidthByChartType={},this.lastTimeFrame=[0,0],this.FAKE_CANDLES_DEFAULT=100,this.toY=p=>this.mainCandleSeries.view.toY(p),this.chartTypeChanged.next(this.config.components.chart.type),this.secondaryChartColors=new H(this.config);const c=new O(this.chartBaseModel,this.paneManager.paneComponents[C],this.paneManager.hitTestController.getNewDataSeriesHitTestId(),this.bus,this.scaleModel,new z,this.candlesTransformersByChartType,this.candleWidthByChartType,Object.assign({},this.config.colors));c.config.type=this.config.components.chart.type,this.candleSeries.push(c),n.addXConstraint((p,u)=>L(u,this.mainCandleSeries.visualPoints,this.config.components.chart.minCandlesOffset,n.getBounds())),this.basicScaleViewportTransformer=X(n),this.timeFrameViewportTransformer=R(n,this),this.pane=this.paneManager.paneComponents[C]}doActivate(){super.doActivate(),this.addRxSubscription(this.canvasBoundsContainer.observeBoundsChanged(f.PANE_UUID(C)).pipe(D(W)).subscribe(e=>{this.handleChartResize(e)})),this.addRxSubscription(this.canvasBoundsContainer.barResizerChangedSubject.subscribe(()=>this.recalculateViewportModelZoomY()))}handleChartResize(e){if(e.width>x.width&&e.height>x.height){const t=this.getEffectiveChartWidth(),s=this.getEffectiveYAxisWidth();if(this.prevChartWidth===0){this.scaleModel.isViewportValid()?this.scaleModel.recalculateZoom():this.doBasicScale(),this.prevChartWidth=t,this.prevYWidth=s;return}if(s!==this.prevYWidth){if(this.config.scale.keepZoomXOnYAxisChange){const a=M(s-this.prevYWidth,this.scaleModel.zoomX);this.scaleModel.setXScale(this.scaleModel.xStart,this.scaleModel.xEnd-a)}else this.scaleModel.recalculateZoomX();this.prevYWidth=s,this.prevChartWidth=t;return}const i=M(t-this.prevChartWidth,this.scaleModel.zoomX);this.scaleModel.setXScale(this.scaleModel.xStart-i,this.scaleModel.xEnd),this.scaleModel.recalculateZoomY(),this.prevYWidth=s,this.prevChartWidth=t}}recalculateViewportModelZoomY(){this.scaleModel.recalculateZoomY(),this.scaleModel.fireChanged(),this.bus.fireDraw([this.canvasModel.canvasId])}setMainCandleSeries(e,t){this.mainCandleSeries.instrument=t,this.setAllSeries({candles:e,instrument:t},this.getSecondarySeries().map(s=>{const i=s.dataPoints;return Z(i),{candles:i,instrument:s.instrument}}))}setSecondaryCandleSeries(e,t=this.mainCandleSeries.instrument,s=!0){const i=y(e.map(S)),a=this.reindexCandlesBasedOnSeries(this.mainCandleSeries.dataPoints,i),n=this.secondarySeriesAdjustments(this.mainCandleSeries.dataPoints,a),d=this.secondaryCandleSeries.some(l=>l.instrument.symbol===t.symbol)?this.secondaryCandleSeries.find(l=>l.instrument.symbol===t.symbol):this.createSecondaryCandleSeriesModel(t);if(d)return d.dataPoints=n,s&&(this.scaleModel.doAutoScale(),d.recalculateVisualPoints(),this.candlesSetSubject.next(),this.bus.fireDraw([this.canvasModel.canvasId])),d}setAllSeries(e,t=[]){var s;this.mainCandleSeries.instrument=(s=e.instrument)!==null&&s!==void 0?s:this.mainCandleSeries.instrument,e.instrument&&this.mainInstrumentChangedSubject.next(e.instrument),this.rememberCurrentTimeframe();const i=y(e.candles.map(S));this.mainCandleSeries.clearData(),b(i),this.mainCandleSeries.dataPoints=i,this.secondaryCandleSeries.filter(a=>t.filter(n=>{var r;return((r=n.instrument)===null||r===void 0?void 0:r.symbol)===a.instrument.symbol}).length===0).forEach(a=>this.removeSecondaryCandleSeries(a)),t.map(a=>this.setSecondaryCandleSeries(a.candles,a.instrument,!1)),this.candleSeries.forEach(a=>{a.recalculateDataViewportIndexes(),a.recalculateVisualPoints()}),this.chartBaseModel.recalculatePeriod(),this.autoScaleOnCandles(),this.scaleModel.doAutoScale(),this.candlesSetSubject.next(),this.bus.fireDraw([this.canvasModel.canvasId])}autoScaleOnCandles(){this.scaleModel.state.autoScaleOnCandles&&(this.doBasicScale(),this.scaleModel.autoScale(!0))}doBasicScale(){this.basicScaleViewportTransformer(this.mainCandleSeries.visualPoints),this.bus.fireDraw()}doPreviousTimeFrameScale(e=null){this.timeFrameViewportTransformer(this.lastTimeFrame,e),this.scaleModel.state.autoScaleOnCandles&&this.scaleModel.doAutoScale(!0),this.bus.fireDraw()}rememberCurrentTimeframe(){this.mainCandleSeries.visualPoints.length!==0&&(this.lastTimeFrame=[this.candleFromX(this.scaleModel.toX(this.scaleModel.xStart),!0).timestamp,this.candleFromX(this.scaleModel.toX(this.scaleModel.xEnd),!0).timestamp])}updateAllSeries(e,t){const s=[e,...t];if(!this.candleSeries.every(r=>s.find(d=>{var l;return((l=d.instrument)===null||l===void 0?void 0:l.symbol)===r.instrument.symbol}))||t.length!==this.secondaryCandleSeries.length){console.error("All series update failed. Instruments for series are different.");return}const i=y(e.candles.map(S)),a=I(this.mainCandleSeries.dataPoints,i),n=a.candles;b(n),this.mainCandleSeries.dataPoints=n,t.map(r=>{var d,l,o,c;const p=y(r.candles.map(S)),u=I((c=(o=this.findSecondarySeriesBySymbol((l=(d=r.instrument)===null||d===void 0?void 0:d.symbol)!==null&&l!==void 0?l:""))===null||o===void 0?void 0:o.dataPoints)!==null&&c!==void 0?c:[],p).candles;return this.setSecondaryCandleSeries(u,r.instrument,!1)}),this.candleSeries.forEach(r=>{r.recalculateVisualPoints(),r.recalculateDataViewportIndexes()}),this.scaleModel.moveXStart(this.scaleModel.xStart+a.prepended),this.candlesPrependSubject.next(a.prepended),this.chartBaseModel.recalculatePeriod(),this.candlesUpdatedSubject.next(),this.bus.fireDraw()}removeDataFrom(e){Object.values(this.paneManager.paneComponents).forEach(t=>{t.dataSeries.forEach(s=>{const i=w(s.dataPoints,e,n=>n.timestamp),a=i.exact?i.index:i.index+1;s.dataPoints=s.dataPoints.slice(0,a)})}),this.candlesRemovedSubject.next(),this.candlesUpdatedSubject.next(),this.canvasModel.fireDraw()}createSecondaryCandleSeriesModel(e){const t=Object.assign(Object.assign({},this.config.colors),this.secondaryChartColors.takeColorFromPool(e.symbol));return this.createCandleSeriesModel(e,t)}createCandleSeriesModel(e,t){const s=new j(this.paneManager.paneComponents[C],this.paneManager.hitTestController.getNewDataSeriesHitTestId(),this.bus,this.scaleModel,e,this.candlesTransformersByChartType,this.candleWidthByChartType,t);return s.config.type="line",this.candleSeries.push(s),s}removeSecondaryCandleSeries(e){return this.secondaryChartColors.addColorToPool(e.instrument.symbol),this.candleSeries=this.candleSeries.filter(t=>t!==e),e.deactivate(),this.paneManager.paneComponents[C].removeDataSeries(e),this.scaleModel.doAutoScale(),e.colors}secondarySeriesAdjustments(e,t){const s=[];return e.forEach(i=>{var a;const n=(a=i.idx)!==null&&a!==void 0?a:0,r=t[n];if(r)s.push(r);else{let d=T(t,n,-1);if(d||(d=T(t,n,1)),d){const l=V(d,n,!0);s.push(l)}}}),s}updateSecondaryCandleSeriesConfig(e,t,s){const i=Y(e,_().colors);this.secondaryChartColors.updateColorConfig(t,i);const a=this.findSecondarySeriesBySymbol(t);a&&(a.config.type=s,a.updateCandleSeriesColors(i),this.bus.fireDraw([this.canvasModel.canvasId])),this.bus.fireDraw([this.canvasModel.canvasId])}setAutoScale(e){this.scaleModel.autoScale(e)}getEffectiveYAxisWidth(){return this.canvasBoundsContainer.getBounds(f.PANE_UUID_Y_AXIS(C)).width}getEffectiveChartWidth(){return this.canvasBoundsContainer.getBounds(f.PANE_UUID(C)).width}getEffectiveChartHeight(){return this.canvasBoundsContainer.getBounds(f.PANE_UUID(C)).height}setOffsets(e){this.scaleModel.updateOffsets(e);const t=this.getCandlesCountWithRightOffset(),s=this.mainCandleSeries.visualPoints;this.hasCandles()&&t>=s.length&&this.scaleModel.setXScale(this.scaleModel.xStart,this.candleFromIdx(t).startUnit),this.offsetsChanged.next(),this.bus.fireDraw()}getOffsets(){return this.scaleModel.getOffsets()}fromY(e){return this.scaleModel.fromY(e)}priceFromY(e,t){return(t!=null?t:this.mainCandleSeries).view.priceFromY(e)}toX(e){const t=this.candleFromIdx(e);return this.scaleModel.toX(t.centerUnit)}getBaseLine(){return this.mainCandleSeries.getBaseLine()}candleFromX(e,t=!1,s=this.mainCandleSeries){const i=this.scaleModel.fromX(e);return this.candleFromUnit(i,t,s)}candleFromUnit(e,t=!1,s=this.mainCandleSeries){var i,a;const n=w(s.visualPoints,e,c=>c.startUnit),r=s.visualPoints,d=this.getLastVisualCandle();r[n.index]!==void 0&&(e<0||d&&e>d.startUnit+d.width)&&(n.index+=K((e-r[n.index].centerUnit)/this.mainCandleSeries.meanCandleWidth));const l=n.index,o=Math.max(Math.min(r.length-1,l),0);return(l<0||l>=r.length)&&t?g(this.mainCandleSeries.dataPoints,l,this.chartBaseModel.period):(a=(i=r[o])===null||i===void 0?void 0:i.candle)!==null&&a!==void 0?a:g(this.mainCandleSeries.dataPoints,o,this.chartBaseModel.period)}candleFromTimestamp(e,t=!0){return this.chartBaseModel.dataFromTimestamp(e,t)}candleFromIdx(e){return this.chartBaseModel.dataFromIdx(e)}isReady(){return this.canvasModel.isReady()&&this.hasCandles()}registerCandlesTransformer(e,t){this.candlesTransformersByChartType[e]=t}registerCandlesWidthCalculator(e,t){this.candleWidthByChartType[e]=t}registerLastCandleLabelHandler(e,t){this.lastCandleLabelsByChartType[e]=t}hasCandles(){return this.mainCandleSeries.visualPoints.length!==0}getVisualCandle(e){var t,s,i;const a=e-((i=(s=(t=this.mainCandleSeries.visualPoints[0])===null||t===void 0?void 0:t.candle)===null||s===void 0?void 0:s.idx)!==null&&i!==void 0?i:0);return this.mainCandleSeries.visualPoints[a]}getFirstIdx(){return this.mainCandleSeries.dataIdxStart}getLastIdx(){return this.mainCandleSeries.dataIdxEnd}getFirstTimestamp(e=!0){return e?this.candleFromIdx(this.getFirstIdx()).candle.timestamp:this.candleFromUnit(this.scaleModel.xStart,!0).timestamp}getLastTimestamp(e=!0){return e?this.candleFromIdx(this.getLastIdx()).candle.timestamp:this.candleFromUnit(this.scaleModel.xEnd,!0).timestamp}setTimestampRange(e,t){const s=this.candleFromTimestamp(e).startUnit,i=this.candleFromTimestamp(t),a=i.startUnit+i.width;return this.scaleModel.setXScale(s,a)}getLastCandle(){const e=this.mainCandleSeries.dataPoints;return P(e)}getLastVisualCandle(){const e=this.mainCandleSeries.visualPoints;return P(e)}getMaxCandlesFitLength(){return k(this.getEffectiveChartWidth()/this.config.components.chart.minWidth)}getSecondarySeries(){return this.secondaryCandleSeries}isSeriesInstrument(e,t){return e.instrument.symbol===t}findSeriesBySymbol(e){return this.candleSeries.filter(t=>this.isSeriesInstrument(t,e))}findSecondarySeriesBySymbol(e){return this.secondaryCandleSeries.find(t=>this.isSeriesInstrument(t,e))}reindexCandlesBasedOnSeries(e,t){return t.reduce((s,i)=>{const a=i.timestamp,n=v(a,!1,e,this.chartBaseModel.period);return n.index>=0&&n.index<e.length&&(i.idx=n.index,s[n.index]=i),s},[])}getPeriod(){return this.chartBaseModel.period}isCandleInViewport(e){return this.getFirstIdx()<=e&&e<=this.getLastIdx()}updateCandles(e,t=this.mainCandleSeries.instrument.symbol){const s=this.mainCandleSeries.instrument.symbol===t,i=this.findSeriesBySymbol(t);if(i.length===0){console.warn("updateCandles failed. Can't find series",t);return}i.forEach(a=>{const n=a.dataPoints;let r=!1,d=!1,l;e.forEach(o=>{var c;if(!o)return;const p=v(o.timestamp,!0,n,this.getPeriod()),u=Math.min(p.index,n.length);r=r||u===n.length,n[u]=o,o.idx=u,a.dataPoints=n,a.recalculateDataViewportIndexes(),d=d||this.isCandleInViewport(u);const B=u>=n.length-1,E=l&&o.timestamp<l.timestamp;if(B&&!E&&(l=o),r&&l&&s&&d){const F=(c=this.candleWidthByChartType[this.config.components.chart.type])!==null&&c!==void 0?c:N;this.scaleModel.moveXStart(this.scaleModel.xStart+F(l))}}),l&&a.updateCurrentPrice(l.close),d&&l&&e.length===1?this.bus.fireDraw([this.canvasModel.canvasId]):a.recalculateVisualPoints()}),this.scaleModel.doAutoScale(),this.candlesUpdatedSubject.next()}observeCandlesChanged(){return A(this.candlesSetSubject,this.candlesUpdatedSubject)}getCandles(){return this.mainCandleSeries.dataPoints}getCandlesWithFake(e=0,t){let s=this.getCandles().slice();const i=this.getCandlesCount(),a=t!=null?t:i+this.FAKE_CANDLES_DEFAULT;s=s.slice(Math.max(0,e),Math.min(i,a));const n=[],r=[];for(let l=i;l<a;l++)n.push(g(this.mainCandleSeries.dataPoints,l,this.getPeriod()));const d=Math.min(0,a);for(let l=e;l<d;l++)r.push(g(this.mainCandleSeries.dataPoints,l,this.getPeriod()));return[...r,...s,...n]}getCandlesCount(){return this.mainCandleSeries.dataPoints.length}getCandlesCountWithRightOffset(){return this.getCandlesCount()+this.getOffsets().right}clearData(){this.candleSeries.forEach(e=>e.clearData())}prependCandles(e,t){const s=e.slice(),i=[];return t.forEach(a=>{const r=v(a.timestamp,!1,e).index;r<0?i.push(a):e[r].timestamp===a.timestamp?s[r]=a:console.warn(`Couldn't update candle with timestamp ${a.timestamp}`)}),{prepended:i.length,candles:[...i,...s]}}addLastCandle(e,t=this.mainCandleSeries.instrument.symbol){this.updateCandles([e],t)}updateLastCandle(e,t=this.mainCandleSeries.instrument.symbol){this.updateCandles([e],t)}}const y=h=>h.slice().sort((e,t)=>e.timestamp===t.timestamp?0:e.timestamp>t.timestamp?1:-1),T=(h,e,t)=>{if(e>=h.length)return h[h.length-1];for(let s=e;s<h.length&&s>=0;s+=t){const i=h[s];if(i)return i}},I=(h,e)=>{const t=h.slice(),s=[],i=[];return e.forEach(a=>{const r=v(a.timestamp,!0,h).index;r<0?s.push(a):r>=h.length?i.push(a):h[r].timestamp===a.timestamp?t[r]=a:console.warn(`Couldn't update candle with timestamp ${a.timestamp}`)}),{prepended:s.length,appended:i.length,candles:[...s,...t,...i]}};
