/*
 * Copyright (C) 2002 - 2023 Devexperts LLC
 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
import{floor as M}from"../utils";import{MathUtils as u}from"./math.utils";class o{static autoDetectIncrementOfValueRange(a){const r=this.getDigitsInNumber(a);return a===0?.01:Math.pow(10,r-3)}static getDigitsInNumber(a){const r=h=>M(Math.log10((h^h>>31)-(h>>31)))+1;let t=r(a);return t===1&&a<1&&(t=r(a*1e9)-9),t}static getPriceIncrement(a,r=[]){if(!this.validatePriceIncrementsOrPrecisions(r))return this.DEFAULT_INCREMENT;if(isNaN(a))return Math.round(r[0]);a=Math.abs(a);let t=1;const h=1e-6;for(;t<r.length&&a>r[t]+Math.min(r[t-1],r[t+1])*h;)t+=2;return t>=r.length||a<r[t]-Math.min(r[t-1],r[t+1])*h?r[t-1]:Math.min(r[t-1],r[t+1])}static getPricePrecision(a,r){if(!this.validatePriceIncrementsOrPrecisions(r))return 0;if(isNaN(a))return Math.round(r[0]);a=Math.abs(a);let t=1;for(;t<r.length&&a>r[t];)t+=2;return Math.round(r[t-1])}static roundPriceToIncrement(a,r,t){const h=o.getPriceIncrement(t||a,r);return u.roundToNearest(a,h)}static computePrecisions(a){const r=[...a];for(let t=0;t<a.length;t+=2)r[t]=o.calculatePrecision(a[t]);for(let t=1;t<a.length;t+=2)r[t]=a[t]+Math.min(a[t-1],a[t+1])*o.RELATIVE_EPS;return r}static calculatePrecision(a){let r=a>1?Math.abs(Math.floor(a)-a):a;for(let t=0;t<o.MAXIMUM_PRECISION;t++){const h=Math.floor(r+.5),i=Math.abs(r*o.RELATIVE_EPS);if(h>=r-i&&h<=r+i)return t;r*=10}return o.MAXIMUM_PRECISION}static validatePriceIncrementsOrPrecisions(a){return!(a.length===0||!Array.isArray(a)||a.findIndex(r=>r!==0)===-1)}}o.DEFAULT_INCREMENT=.01,o.DEFAULT_PRECISION=2,o.RELATIVE_EPS=1e-8,o.MAXIMUM_PRECISION=10;export{o as PriceIncrementsUtils};
