/*
 * Copyright (C) 2002 - 2023 Devexperts LLC
 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
import{create2DArray as l,slice2DArray as d}from"../../common/array.functions";import{ChartBaseElement as c}from"../chart-base-element";import{DataSeriesYAxisLabelsProvider as u}from"../components/y_axis/price_labels/data-series-y-axis-labels.provider";import{MathUtils as P}from"../utils/math.utils";import{merge as x}from"../utils/merge.utils";import{cloneUnsafe as I}from"../utils/object.utils";import{binarySearch as r,lastOf as g}from"../utils/utils-index";import{DataSeriesView as v}from"./data-series-view";import{DEFAULT_DATA_SERIES_CONFIG as h}from"./data-series.config";export class DataSeriesModel extends c{get dataPoints2D(){return this._dataPoints}get dataPoints(){return this._dataPointsFlat}set dataPoints(t){this._dataPoints=l(t),this._dataPointsFlat=this._dataPoints.flat(),this.visualPoints=this._toVisualPoints(this._dataPoints)}get visualPoints(){return this._visualPointsFlat}get visualPoints2D(){return this._visualPoints}set visualPoints(t){this._visualPoints=l(t),this._visualPointsFlat=this._visualPoints.flat()}constructor(t,i,e=I(h)){super(),this.paneComponent=t,this.id=i,this.name="",this.hovered=!1,this._dataPoints=[],this.pricePrecisions=[.01],this.linkedDataSeriesModels=[],this._dataPointsFlat=[],this._visualPoints=[],this._visualPointsFlat=[],this.dataIdxStart=0,this.dataIdxEnd=0,this.getPaintConfig=a=>{var s;return(s=this.config.paintConfig[a])!==null&&s!==void 0?s:this.config.paintConfig[0]},this.getBaseLine=(a=this.dataIdxStart)=>{var s,n;return(n=(s=this.visualPoints[a])===null||s===void 0?void 0:s.close)!==null&&n!==void 0?n:1},this.getTextForPoint=a=>`${a.close}`,this.getLastVisualSeriesPoint=()=>{const a=this.visualPoints,s=r(a,this.scaleModel.xEnd,n=>n.centerUnit).index;return a[s]},this.getLastDataSeriesPoint=()=>{const a=this.visualPoints;return g(a)},this.config=x(e,h),this.scaleModel=t.scaleModel,this.view=new v(this,this.scaleModel,()=>this.paneComponent.getAxisType(),this.getBaseLine),this.yAxisLabelProvider=new u(this,this.config,t.getYAxisBounds),this.highLowProvider=f(this),t.addDataSeries(this),this.addRxSubscription(this.scaleModel.xChanged.subscribe(()=>this.recalculateDataViewportIndexes())),this.addRxSubscription(this.scaleModel.scaleInversedSubject.subscribe(()=>this.recalculateVisualPoints()))}_toVisualPoints(t){return t.map(i=>this.toVisualPoints(i))}toVisualPoints(t){return t.map((i,e)=>({centerUnit:e,close:i.close}))}recalculateVisualPoints(){this.visualPoints=this._toVisualPoints(this.dataPoints2D)}recalculateDataViewportIndexes(t=this.scaleModel.xStart,i=this.scaleModel.xEnd){const{dataIdxStart:e,dataIdxEnd:a}=this.calculateDataViewportIndexes(t,i);this.dataIdxStart=e,this.dataIdxEnd=a}calculateDataViewportIndexes(t,i){const e=r(this.visualPoints,t,s=>s.centerUnit).index,a=r(this.visualPoints,i,s=>s.centerUnit).index;return{dataIdxStart:e,dataIdxEnd:a}}valueFormatter(t){return defaultValueFormatter(t)}getSeriesInViewport(t,i){let e=this.dataIdxStart,a=this.dataIdxEnd;if(i!==void 0&&t!==void 0){const s=this.calculateDataViewportIndexes(t,i);e=s.dataIdxStart,a=s.dataIdxEnd}return d(this.visualPoints2D,e,a)}}export const calculateDataSeriesHighLow=o=>{const t={high:Number.NEGATIVE_INFINITY,low:Number.POSITIVE_INFINITY,highIdx:0,lowIdx:0};for(let i=0;i<o.length;i++){const e=o[i];e.close>t.high&&(t.high=e.close,t.highIdx=i),e.close<t.low&&(t.low=e.close,t.lowIdx=i)}return t};const f=o=>({isHighLowActive:()=>o.config.highLowActive,calculateHighLow:t=>{const i=calculateDataSeriesHighLow(o.getSeriesInViewport(t==null?void 0:t.xStart,t==null?void 0:t.xEnd).flat());return Object.assign(Object.assign({},i),{high:o.view.toAxisUnits(i.high),low:o.view.toAxisUnits(i.low)})}});export const defaultValueFormatter=o=>{const i=s=>Math.ceil(Math.log(Math.abs(s))*Math.LOG10E),a=((s,n=5)=>Math.max(0,n-Math.max(0,i(s))))(o);return P.makeDecimal(o,a)};
