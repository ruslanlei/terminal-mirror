/*
 * Copyright (C) 2002 - 2023 Devexperts LLC
 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */
import{clipToBounds as p}from"../../drawers/data-series.drawer";import{unitToPixels as u}from"../../model/scaling/viewport.model";import{ceilToDPR as m,floorToDPR as n}from"../../utils/device-pixel-ratio.utils";import{resolveColorForCandle as f}from"./volume-color-resolvers.functions";const w=3;export class VolumesDrawer{constructor(e,t,o,i,l,s,r){this.canvasModel=e,this.config=t,this.volumesModel=o,this.chartModel=i,this.viewportModel=l,this.volumesColorByChartTypeMap=s,this.drawPredicate=r,this.volumeBarColors={down:"#FF00FF",up:"#FF00FF",none:"#FF00FF"}}calculateColors(e){var t;const o=(t=this.volumesColorByChartTypeMap[e])!==null&&t!==void 0?t:f;this.volumeBarColors.down=o("down",this.config.colors),this.volumeBarColors.up=o("up",this.config.colors),this.volumeBarColors.none=o("none",this.config.colors)}draw(){if(this.config.components.volumes.visible&&this.drawPredicate()){this.calculateColors(this.config.components.chart.type);const e=this.canvasModel.ctx;e.save();const t=this.viewportModel.getBounds();p(e,t),this.drawVolumes(),e.restore()}}drawLastBar(){this.config.components.volumes.visible}drawVolumes(){const e=this.volumesModel.volumeMax.getValue();if(e===0)return;const t=this.chartModel.mainCandleSeries.getSeriesInViewport().flat();t.forEach((o,i)=>{if(o.candle.volume){const l=this.viewportModel.getBounds(),s=l.height,r=t[i+1]!==void 0?n(this.viewportModel.toX(t[i+1].startUnit)):void 0,c=n(this.viewportModel.toX(o.startUnit)),a=r!==void 0?r-c:n(u(o.width,this.viewportModel.zoomX));if(this.config.components.volumes.showSeparately){const h=n(this.viewportModel.toY(o.candle.volume)),d=n(this.viewportModel.toY(0))-h;this.drawVolume(o,c,h,a,d)}else{const h=e/(s/w),d=Math.max(u(o.candle.volume,h),2),v=n(l.y+s-d);this.drawVolume(o,c,v,a,d)}}})}drawVolume(e,t,o,i,l){const s=this.canvasModel.ctx,r=o,c=o+l,a=e.name;s.fillStyle=this.volumeBarColors[a],s.strokeStyle=this.volumeBarColors[a],i===0?(s.beginPath(),s.moveTo(t,r),s.lineTo(t,m(c)),s.stroke()):s.fillRect(t,o,i,m(l))}getCanvasIds(){return[this.canvasModel.canvasId]}}
